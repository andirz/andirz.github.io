---
layout: page
title: Search
permalink: /search/
---

<div class="search-page">
  <div class="search-box">
    <input id="my-search-q" class="form-control" type="search" placeholder="Search…" autocomplete="off" />
    <div class="search-hint text-muted" style="margin-top:8px; font-size:0.9rem;">
      Tip: try words like “core”, “pso”, “skill”, “install”…
    </div>
  </div>

  <!-- Chirpy will unten im Theme nochmal SimpleJekyllSearch initialisieren und erwartet #search-input.
       Damit das nicht crasht (und deinen Code mitreißt), geben wir ihm ein unsichtbares Dummy-Input. -->
  <input id="search-input" type="search" style="position:absolute; left:-9999px; width:1px; height:1px; opacity:0;" aria-hidden="true" tabindex="-1" />

  <div id="my-search-status" class="text-muted" style="margin-top:14px;"></div>
  <div id="my-search-groups" style="margin-top:18px;"></div>
</div>

<style>
  .search-page { max-width: 860px; }
  #my-search-groups section { margin-top: 22px; }
  #my-search-groups h2 { font-size: 1.25rem; margin: 0 0 10px 0; }
  #my-search-groups .search-results article {
    margin: 14px 0;
    padding: 12px 14px;
    border: 1px solid var(--border-color);
    border-radius: 12px;
    background: var(--bg-primary);
  }
  #my-search-groups .search-results h3 { margin: 0; font-size: 1.05rem; }
  #my-search-groups .search-results p { margin: 6px 0 0; opacity: .9; line-height: 1.35; }
  #my-search-groups .count { font-size: .95rem; opacity: .7; }
</style>

<script>
(() => {
  const input  = document.getElementById('my-search-q');
  const status = document.getElementById('my-search-status');
  const groups = document.getElementById('my-search-groups');

  if (!input || !status || !groups) return;

  status.textContent = 'Loading search index…';

  const ORDER = [
    ['mods',  'Mods'],
    ['wiki',  'Sims 4 Wiki'],
    ['tools', 'Modding Tools'],
    ['games', 'Game Center'],
    ['posts', 'Blog'],
    ['pages', 'Pages']
  ];
  const TITLES = Object.fromEntries(ORDER);

  const esc = (s) => (s || '').replace(/[&<>"']/g, c => ({
    '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'
  }[c]));

  function snippet(text, q) {
    const t = (text || '').replace(/\s+/g, ' ').trim();
    if (!t) return '';
    if (!q) return t.slice(0, 180) + (t.length > 180 ? '…' : '');

    const needle = q.toLowerCase();
    const low = t.toLowerCase();
    const idx = low.indexOf(needle);

    if (idx === -1) return t.slice(0, 180) + (t.length > 180 ? '…' : '');

    const start = Math.max(0, idx - 60);
    const end   = Math.min(t.length, idx + needle.length + 90);
    return (start > 0 ? '…' : '') + t.slice(start, end) + (end < t.length ? '…' : '');
  }

  function render(grouped, q) {
    groups.innerHTML = '';

    const total = Object.values(grouped).reduce((a, arr) => a + arr.length, 0);

    if (!q.trim()) {
      status.textContent = 'Type to search…';
      return;
    }

    if (!total) {
      status.textContent = 'Oops! No results found.';
      return;
    }

    status.textContent = `${total} result${total === 1 ? '' : 's'} found.`;

    const known = new Set(ORDER.map(([k]) => k));
    const orderedKeys = ORDER.map(([k]) => k).filter(k => (grouped[k] || []).length);
    const unknownKeys = Object.keys(grouped).filter(k => !known.has(k) && (grouped[k] || []).length).sort();

    [...orderedKeys, ...unknownKeys].forEach(key => {
      const items = grouped[key] || [];
      if (!items.length) return;

      const title = TITLES[key] || (key.charAt(0).toUpperCase() + key.slice(1));

      const section = document.createElement('section');
      section.innerHTML = `<h2>${esc(title)} <span class="count text-muted">(${items.length})</span></h2>`;

      const list = document.createElement('div');
      list.className = 'search-results';
      section.appendChild(list);

      items.forEach(it => {
        const card = document.createElement('article');
        card.innerHTML = `
          <h3><a href="${esc(it.url)}">${esc(it.title)}</a></h3>
          <p class="text-muted">${esc(snippet(it.content, q))}</p>
        `;
        list.appendChild(card);
      });

      groups.appendChild(section);
    });
  }

  let data = [];

  function doSearch(q) {
    q = (q || '').trim();
    if (!q) { render({}, ''); return; }

    const needle = q.toLowerCase();

    const matches = data.filter(it => {
      const t = (it.title || '').toLowerCase();
      const c = (it.content || '').toLowerCase();
      return t.includes(needle) || c.includes(needle);
    });

    const grouped = {};
    matches.forEach(it => {
      const k = it.collection || 'pages';
      (grouped[k] ||= []).push(it);
    });

    // einfache Sortierung: Titel-Treffer zuerst
    Object.keys(grouped).forEach(k => {
      grouped[k].sort((a, b) => {
        const at = (a.title || '').toLowerCase().includes(needle) ? 0 : 1;
        const bt = (b.title || '').toLowerCase().includes(needle) ? 0 : 1;
        return at - bt;
      });
    });

    render(grouped, q);
  }

  (async () => {
    try {
      const url = '{{ "/assets/js/data/search.json" | relative_url }}';
      const res = await fetch(url, { cache: 'no-store' });

      if (!res.ok) {
        status.textContent = `Search index not found: ${url} (HTTP ${res.status})`;
        return;
      }

      data = await res.json();
      status.textContent = `Index loaded (${data.length} items). Type to search…`;

      const params = new URLSearchParams(location.search);
      input.value = params.get('q') || '';

      input.addEventListener('input', () => {
        const q = input.value;
        const p = new URLSearchParams(location.search);
        q ? p.set('q', q) : p.delete('q');
        history.replaceState(null, '', `${location.pathname}${p.toString() ? '?' + p.toString() : ''}`);
        doSearch(q);
      });

      doSearch(input.value);
    } catch (e) {
      status.textContent = 'Search crashed: ' + (e && e.message ? e.message : String(e));
      console.error(e);
    }
  })();
})();
</script>
